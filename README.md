# learn-computer-science
FIX TOC
# 🧭 Table of Contents
- [🚀 Preface]()
    + [💼 Career Development]()
    + [🤷‍♂️ What is OSSU?]()
    + [⏰ Statement of Commitment]()
    + [✏️ Copyright]()
- [🗃️ How This Repository is Organized]()
- [🐍 Harvard - CS50 - Introduction to Programming with Python]()
- [👨‍💻 MIT - 6.0001 - Introduction to Computer Science and Programming using Python]()
- [📏 UBC - CPSC110 - Systematic Program Design]()
- [🧪 UW – CSE341 – Programming Languages A, B, & C]()
    + [🎾 Perhaps I Was Too Hard on Racket (Bonus Segment)]() 

---

# 🚀 Preface
>### *“Who wants to be pulling all-nighters because they can’t find a bug in their program?”*

Is the reason I gave for not studying computer science. I decided to study mechanical engineering instead, as I knew I liked making things and I was good at math and science. While in retrospect, that statement about computer science was naïve, I still believe that mechanical engineering was the correct choice for me. I’ve been satisfied with what I’ve learned, and I’ve acquired lots of skills that will be practical in the future. However, the omnipresence of software in every facet of daily life makes these engineering skills by themselves less useful in isolation. I believe that to truly succeed in today’s world, it is necessary to acquire both engineering and computer science skills.

Many of my hobby projects have focused on some form of software development. Projects centered around web development, game development, graphics programming, and the like have been able to capture my attention for months at a time. Though, most of these projects would follow a similar trend. I would quickly make progress and rapidly learn and apply new programming concepts. However, I would always run into knowledge or skill barriers that I wouldn’t be able to overcome due to my lack of foundational knowledge in computer science. As a result, I would lose motivation for a project and quickly abandon it for my next big interest. These projects were useful for building skills in the short term, but have resulted in my computer science knowledgebase being more akin to pockets of skills rather than a deep understanding of concepts.

Realizing these two ideas﹘The importance of understanding computer science and my lack thereof﹘has given me the necessary drive to self-study computer science. Ironically, not choosing computer science as my major may have been the best thing that has happened to me in regard to computer science. Self-study is advantageous in the fact that I can pace my learning in a way that is appropriate for me, while still getting a complete education. Self-study also forces me to take the initiative to learn rather than being forced to by social expectations or financial pressures. I’m in control of my own success or failure, which is quite satisfying.
### 💼 Career Development
One objective of my continued self-education in computer science has always been to open more career opportunities for myself in the future. My goal is to reach a point where if I chose to, I could shift from an engineering role to a software role, or somewhere in between. The way to do this is to reach a skill level that is competitive with those pursuing an undergraduate degree in computer science. My intentions with Open-Source Society University are thus to provide myself with a self-guided formal education to achieve this goal.
### 🤷‍♂️ What is OSSU?
[Open Source Society University (OSSU)](https://ossu.firebaseapp.com/#/about) provides a path for anyone to self-study computer science. In their own words, OSSU provides “a complete education in computer science” through free online courses from top universities. OSSU emphasizes that their resources are for “those who want a proper, well-rounded grounding in concepts fundamental to all computing disciplines”. The curriculum is designed according to the degree specifications for undergraduate computer science majors.

The courses selected are open for free enrollment and are “of high quality in teaching materials and pedagogical principles”. Courses are only selected if they meet the [Curriculum Guidelines for Undergraduate Degree Programs in Computer Science]( https://www.acm.org/binaries/content/assets/education/cs2013_web_final.pdf). If no available online courses meet this criterion, the course is supplemented with online reading. Completion of the OSSU curriculum involves taking around 40 online courses.

_Learn more about Open Source Society University at:_ [ossu/computer-science](https://github.com/ossu/computer-science)
### ⏰ Statement of Commitment
*I intend to commit 20 hours a week, or slightly less than 3 hours every day to learning computer science. This number is intended to be an average, and it is acceptable if the hours I spend on OSSU vary day-by-day. However, I do intend to commit at least 30 minutes every day to this education.*
### ✏️ Copyright
*I give permission for any person to distribute or share this README article for informational or entertainment purposes only. I do not give permission for this README article to be distributed for monetary gain without my consent. I do not give permission for any person to plagiarize this article or claim it as their own original work.*

---

# 🗃️ How This Repository is Organized
This section provides a brief overview of how the materials in this repository are organized. The content is split into three sections.
#### 👨‍💻 Coursework
This folder contains all the code I have written for courses. This includes the type-along code from lectures and all the homework code I have completed.
#### 📓 Notes
This folder contains all the notes I have written while taking these courses. I use [Notion](https://www.notion.so/product) to type out and save all my notes. I then export them from Notion into PDFs which I upload to GitHub.
#### 📜 Certificates
Certificates of completion for courses I have passed are in this directory. It doesn’t matter to me that some courses don’t offer free certification, as the notes and coursework sections of this repository are sufficient proof of work for them. One of my goals with OSSU is to prove that myself, and anyone else, can self-study computer science *for free*. Therefore, paying for any course certificates would go against this philosophy.

---

#### _One final note: README Updates_
This article is most often updated after completion of each course in the OSSU curriculum. Otherwise, I will usually only update it to fix typos (English language bugs, one might say) or make wording adjustments. In addition, my opinions are subject to change due to the insights and knowledge I gain from taking new courses. Therefore the README is constantly updated to reflect my current thoughts and feelings.

---

# 🐍 Harvard - CS50 - Introduction to Programming with Python
Start Date: `11/01/2023` ---> End Date: `11/25/2023`
Time | Estimate | Actual
--- | --- | ---
Weeks | 10 | 3.6
Hours | 100 | 41.2
Hours/Week | 10 | 11.5
## 🔙 Retrospective
Part of what makes Harvard's Introduction to Programming with Python so great is Professor David J. Malan’s ability to teach programming concepts clearly and concisely. One problem I have encountered with many teachers is that they assume their students have a certain level of prerequisite knowledge. This prevents the teacher from fully communicating a topic to their students, due to a lack of parity in implicit knowledge between them and their. Malan has the unique ability to approach computer science from the outside perspective of a programming novice, despite his own expert proficiency with computer science. His stress on incremental improvement of code and reliance of building off of previously taught concepts make his lectures easily digestible even from a CS outsider. His high energy 💥 and passion during lectures made me more excited to learn programming than I have been in a long time.  

Malan uses Python as a tool to teach programming, not to teach Python. Python is treated as a medium to learn programming concepts, and the language is taught along the way as a side effect. This was a sharp deviation from the Introduction to Programming for Non-Majors course I took at my university. That course tunnel-visioned on the Python language and expected the student to learn programming concepts along the way. CS50 was able to teach me much more than that course could, to a greater effect, despite CS50 being online and asynchronous.
### 💡 What I Learned
Given my previous experience with programming I did not expect to learn much (I was wrong). I routinely found myself learning new concepts and having gaps in my knowledge filled. For example, I now know the difference between function parameters and arguments (Yes, really). I was genuinely surprised by how much content is crammed into the course’s 10 lectures (And three mini-lectures). The topics covered are diverse, practical, and foundational for a further education in computer science. Malan starts by teaching basics like variables, conditionals, loops, and functions. The content quickly accelerates to cover APIs, data persistence, regular expressions, and so on. Despite the large selection of topics covered, I never once felt overwhelmed by new information. In addition, the homework felt like an opportunity to put what was learned in class into practice rather than busy work.
### 👎 Dislikes
My one, probably unfair, nitpick is that the lectures are not a consistent length. Lectures vary from less than an hour to three hours in length.
### 🤔 Suggestions for Students
Don’t be afraid to pause the lectures and go slow. You will learn much more if you code along with Malan during lectures and take notes on important points. Conversely, don’t be afraid to go off the rails and try to predict what Malan will write if you feel confident. One great part of this course is that it encourages you to learn through experimentation.
## 🔑 *Key Takeaways*
* Part of good programming is trying to find a balance between compactness and readability.
* Don’t try to write a program all at once. Incremental progress is important for catching bugs in one’s code and improving it over time.
* Testing code with unit tests is important to confirm that the overall functionality of a function doesn’t change, even if the code inside the function does change.

---

# 👨‍💻 MIT - 6.0001 - Introduction to Computer Science and Programming using Python
Start Date: `11/28/2023` ---> End Date: `12/17/2023`
Time | Estimate | Actual
--- | --- | ---
Weeks | 9 | 3
Hours | 135 | 26
Hours/Week | 15 | 8.7
## 🔙 Retrospective
MIT's Introduction to Computer Science and Programming using Python has advantages in the fact that the topics it chooses to cover are examined in high detail. Topics that are previously covered in Harvard's CS50 like string manipulation and OOP are broken down from the perspective of a computer scientist rather than just a programmer. This decision to approach problems from both a theoretical and applied perspective allows one to deeply understand each topic, no matter what programming language or implementation is being used. My favorite lectures, by far, were those from Professor Eric Grimson. He has a confident, well-paced lecturing style that I really enjoyed listening to. Unlike Professor Ana Bell's lectures, his lectures tended to cover subject matter that was not covered in CS50.
### 💡 What I Learned
Where this course really shines is its lectures on recursion, data structures, algorithms, and program efficiency. Before this course, I had no experience writing a recursive program. I had heard mentions of recursion in passing and believed that it was more of a stylistic choice for programs that anything else. However, through 6.0001 I learned that the implementation of a program is very important in deciding its efficiency. Choosing to implement an algorithm iteratively or recursively can result in a large difference in the time complexity for a program. I had also heard of order of growth notation in passing, but never really understood it. I now understand its purpose for analyzing the complexity of algorithms in relation to their inputs. This tool will be extremely useful in the future for analyzing my programs' time efficiency.

I really enjoyed working on the problem sets. Each one was a great way to apply what one had learned up to that point. Each problem set was designed around building a complete and useful program, so that each time I was working towards a concrete goal. The clear, well laid out function skeletons with docstrings meant that I was never confused about how to proceed through a problem, while also leaving the implementation details of a program for myself to figure out.
### 👎 Dislikes
In my opinion, 6.0001 was difficult to get into. I attribute part of this difficulty to the fact that the course I took prior to this one, Harvard's CS50, was so great. 6.0001 repeats a lot of the same topics covered in CS50, but with less energy. Dr. Ana Bell, while obviously very knowledgeable of the lecture topics, is not the most engaging teacher in my opinion.

Additionally, there are very few opportunities during lectures to program along with the professor. This causes the learning to feel very disjointed, as you are digesting a lot of information and not coding during the lectures, and then coding a lot during the problem sets.
### 🤔 Suggestions for Students
Like most online courses, take the time to pause or slow down the playback speed of the lecture if you feel that the Professor is talking too fast. I found this especially important for this course since many of the lecture slides were sped through or skipped entirely. I had a tab open on the side with the lecture slides to remedy this. Additionally, be aware that the problem sets (except for problem set 0) will take a long time. I ended up splitting my work on them up over the course of multiple days.
## 🔑 *Key Takeaways*
* Computer science and programming are not synonyms.
* It is important to analyze an algorithm separately from its implementation in code, or the machine it is being run on.
* Order of growth, or "Big O", notation measures the *worst case* upper bound on the asymptotic growth of an algorithm in terms of its input.
* Recursion is a useful method for implementing algorithms that has many advantages and disadvantages compared to iteration.

---

# 📏 UBC - CPSC110 - Systematic Program Design
Start Date: `12/25/2023` ---> End Date: `01/03/2024`
Time | Estimate | Actual
--- | --- | ---
Weeks | 13 | 1.5
Hours | 104-130 | 54.8
Hours/Week | 8-10 | 36.5
## 🔙 Retrospective
Before taking this course, I assumed that a skilled intuition for designing programs could only be developed though exposure and practice. Professor Gregor Kiczales' instruction in CPSC110 has managed to convince me otherwise. During the course, Kiczales shows how simple design techniques can be built upon one another to write functions for increasingly complex programs. He constantly expresses the importance of learning by doing and encourages students to work ahead of him to prove their growing intuition for program design. At first, I disliked the course's slow pacing. Over time however, I came to realize that this slow pace allows him to methodically step through the thought-process needed for designing functions. CPSC110 emphasizes the importance of working through the design process correctly rather than quickly.

My only exposure to Racket before taking this course was listening to my CS- and DS-major friends complain about how terrible it is. After heavy exposure to the language myself I can't say I disagree, but did I find that Racket excels at teaching systematic program design. Racket’s simplicity compared to other programming languages forces you to start from first principles and not rely on higher-level program abstractions to solve problems. This benefits in the fact that barely more than a single lecture is spent getting comfortable with the language, which allows students to focus less on the language and more on systematic program design.
### 💡 What I Learned
This course is valuable in the fact that it teaches students to design programs in a, well, systematic manner. You are first taught the best practices to convert real world information into data definitions implemented in code. Kiczales details how these "data definitions" can be used to create templates for functions that operate on those data definitions. I will admit that at first, I was skeptical that these templates were a one-size-fits-all skeleton for any function. Despite my skepticism, it is proven through example that these templates can be adapted to any function necessary. Although it is not shown in the course, it is mentioned that the systematic program design process taught is built on top of a very solid foundation of computer science theory. This leads into the process of systematic function design, where an algorithm is taken from a type signature to a working function through a series of increasingly involved steps. CPSC110's goal is, as Kiczales says, to break program design down to a science, rather than typing code and hoping for the best.
>> I’ve continued to apply the systematic design process to future courses, and I can say with certainty that it makes designing functional programs much easier. In addition, it has encouraged me to spend more time writing unit tests, as I have found them extremely useful for understanding how a functions should work before I invest time coding them.
### 👎 Dislikes
The DrRacket IDE is slow and clunky, and many keywords in the Racket language are oddly cryptic. Writing a "big bang" function for my "world program" was just one of many times when I wondered if the creators of Racket thought it more important to be unique than practical. In addition to this, every expression in Racket is enclosed in parentheses. _This came to its natural conclusion when I found myself nesting up to eight sets of parentheses for a program_. While this issue can be partially remedied by careful and consistent indentation, it makes the program design process a nightmare. I believe that the onus for designing readable code should fall on the designer(s) of a language's syntax first and foremost. Programmers should not be limited by a programming language when trying to write readable code.

>>While I still believe that programming languages should be designed to be readable, my opinions about Racket have changed significantly after taking the University of Washington Seattle’s Programming Languages course. You can read my updated thoughts on Racket in [🎾 Perhaps I Was Too Hard on Racket (Bonus Segment)]()

A major gripe with the course specifically is that the final project is off-limits to students that do not follow the paid track. I would have liked the opportunity to use the skills I developed through the second half of the course in a cumulative exercise. Fortunately, the practice problems and midterm project are available for free, so I don't feel that I missed out on much.
### 🤔 Suggestions for Students
Get comfortable using recursion. A purely functional programming language means no iteration, which means that you need to gain a deep understanding of recursive programs to succeed.

Like Kiczales suggests, program ahead of him at times (when you are feeling confident) to prove to yourself that you aren't blindly programming along with him.
## 🔑 *Key Takeaways*
* Systematic design uses higher-level design concepts to break down complicated problems to a point where one can solve them simply.
* Identifying the structure of information is a key step in program design.
* Unit tests should be made before writing a function, as this allows you to figure out what you really want the output of the function to be.
* Given a base case, trust that the natural recursion in a program will work as expected.
  
---

# 🧪 UW – CSE341 – Programming Languages A, B, & C
Start Date: `01/04/2024` ---> End Date: `02/03/2024`
Time | Estimate | Actual
--- | --- | ---
Weeks | 11 | 4
Hours | 44-88 | 90
Hours/Week | 4-8 | 22.5
## 🔙 Retrospective
 “Programming Languages” is quite a misleading course name, since the focus of the course is not on the syntax of different programming languages, but the semantics and idioms that they all share. Professor Dan Grossman’s extensive knowledge of programming languages, along with his dry humor, makes this course’s lecture videos a pleasure to sit through. His lectures “pull back the curtain” on programming constructs to understand them at their most basic and fundamental level. It is extremely interesting to see how all programming languages, at their core, can be broken down into their semantics, type checking rules, and evaluation rules. Although this course uses ML, Racket, and Ruby, it is repeatedly emphasized that the focus of the course is not on those languages and that they are only conduits to understand the more foundational aspects of programming languages. For example, ML and Ruby are contrasted to understand the differences between statically versus dynamically typed languages, and functional versus object-oriented languages. Over time, ideas are accumulated such that they can be compared and contrasted with new concepts taught. This makes for a course that, at first seems shallow in its content, but makes for some satisfying realizations later on about the inner workings of any programming language.

I’ve found that this course is the most challenging one I’ve taken so far. The homework is exacting in the sense that you have to read the requirements very carefully to receive a satisfactory grade. In addition to the complex homeworks, there are three exams interspersed throughout to test your knowledge of the course material. This contrasts with the previous courses I’ve taken which ask you to apply your knowledge to homework, but do not test it any further beyond that. Course material is locked behind homework and exams, that you must get an 80% or higher on in order to access. By the end, this makes the student feel much more accomplished with their completion of the course. Grossman is extremely aware of the accomplishments of those who are able to complete the course and openly acknowledges the many hours of work students invest into completing it.
### 💡 What I Learned
The most important idea that Grossman draws attention to is that programming languages are only interfaces for writing software and that programming language semantics are more important, since they are the rules that determine how a program behaves. The homeworks are built in a way to apply and challenge your newfound knowledge of these semantics. For example, I found the programming construct “thunks” extremely difficult to understand. It was only when, in a homework that focuses on streams, that I was asked to use them, that I was forced to take the time to understand them to do the homework properly.

This may seem obvious. Of course you need to understand the ideas presented in a homework to do well on it. However, these homeworks need to be understood deeply enough so that by the time you finish the homework, you feel like you have learned something rather than having just scrapped by. This is especially important since much of the content in this course is naturally cumulative, and therefore you will have the knowledge needed to tackle problems when old concepts are revisited.

My favorite learning experience was from what is touted as the most challenging homework. This homework is unique since the goal is to write a made-up programming language interpreter. This homework was remarkably effective for strengthening my understanding of interpreters, and it really felt like an application of my cumulative knowledge so far in that course. The implementation of a target language using a metalanguage (in this case, Racket) was a great way to understand what goes on under the hood of many programming languages. It reshaped my entire understanding about how functions are evaluated, and made the differences between functions, closures, and environments clear to me. It was also important for understanding how an interpreter error-checks a dynamic language.
### 👎 Dislikes
Unfortunately, the image of Grossman jumping up and down telling me that subtyped function arguments are contravariant is still burned into my brain.
### 🤔 Suggestions for Students
This is a challenging course. Make sure you understand the lecture material, or you will not pass the homework or exams. Take time to understand each language construct and how they work together to create more complex behavior.
## 🔑 *Key Takeaways*
* All programming language behaviors are the result of semantics, type checking, and evaluation rules.
    * Syntax is just an interface for writing software.
* Often, compiled/interpreted, statically/dynamically typed, and functional/object-oriented programming languages do not exist as most sit on a spectrum between these hard definitions.
* An environment is simply a mapping from variable names to values.
* The purpose of software is to take simple language constructs and combine them with human ingenuity to create complex systems.


## 🎾 Perhaps I Was Too Hard on Racket (Bonus Segment)
<img src="https://imgs.xkcd.com/comics/lisp_cycles.png"
     alt="XKCD 297"
     style="margin-right: 10px;" />
>##### *From XKCD 297 – Lisp Cycles*
### Parentheses are Good, Actually
One construct touched on in Programming Languages is the abstract syntax tree (AST). ASTs are essentially a tree of how a language interpreter breaks down a program into smaller components that are evaluated based on their syntax. Racket’s parentheses are highly meaningful, as each pair of parentheses essentially represents a node in an AST, and the separate expressions contained in those parentheses are different branches of the AST. This heavy use of parentheses makes Racket a great metalanguage to implement other programming languages in, as the interpreter for the target language would simply be a recursive Racket function.

Homework five of Programming Languages backs up this claim by having the student create a made-up programming language (aptly named MUPL) with Racket as the metalanguage. As mentioned previously, this homework is deeply fulfilling since it applies many of the cross-lecture concepts taught in Programming Languages and gives a better understanding of interpreters among other things. Racket makes breaking down the interpretation of MUPL into concrete steps easy to follow, as each evaluation is roughly equivalent to wrapping an expression in parentheses. Grossman’s in-depth analysis of Racket’s semantics gave me a much greater appreciation for the programming language than I did before.
### Would I Use Racket?
I think that Grossman put it most succinctly by saying that:
>*“…[one] is entitled to [their] opinion about syntax, but a good historian wouldn’t refuse to study a country where they didn’t like people’s accents”*.

At the end of the day, a programming language is an interface for writing software, and the choice to use Racket or not would entirely depend on if it were the best tool for the job. I’ve learned that part of being a good computer scientist is exploring technologies outside of your comfort zone to learn new skills, become more knowledgeable, and discover new tools you might actually enjoy using.

---

### README Changelog
Date | Changes
--- | ---
November 25, 2023 | <ul><li>**ADDED**<ul><li>Preface</li><li>Harvard - CS50 - Introduction to Programming with Python.</li></ul></li></ul>
December 25, 2023 |  <ul><li>**ADDED**<ul><li>Table of Contents</li><li>MIT - 6.0001 - Introduction to Computer Science and Programming using Python.</li></ul></li><li>**REVISED**<ul><li>Preface</li><li>Harvard - CS50 - Introduction to Programming with Python.</li></ul></li></ul>
January 03, 2024 | <ul><li>**ADDED**<ul><li>UBC - CPSC110 - Systematic Program Design.</li></ul></li></ul>
February XX, 2024 |  <ul><li>**ADDED**<ul><li>What is OSSU?</li><li>How This Repository is Organized</li><li>Programming Languages<ul><li>Perhaps I Was Too Hard on Racket (Bonus Segment)</li></ul></li></ul></li><li>**REVISED**<ul><li>Preface</li>Systematic Program Design</li></ul></li></ul>
