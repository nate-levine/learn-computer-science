# learn-computer-science
# 🧭 Table of Contents
- [🚀 Preface](#-preface)
    + [💼 Career Development](#-career-development)
    + [🤷‍♂️ What is OSSU?](#%EF%B8%8F-what-is-ossu)
    + [⏰ Statement of Commitment](#-statement-of-commitment)
    + [✏️ Fair Use](#%EF%B8%8F-fair-use)
- [🗃️ How This Repository is Organized](#%EF%B8%8F-how-this-repository-is-organized)
- [🐍 Harvard - CS50 - Introduction to Programming with Python](#-harvard---cs50---introduction-to-programming-with-python)
- [👨‍💻 MIT - 6.0001 - Introduction to Computer Science and Programming using Python](#-mit---60001---introduction-to-computer-science-and-programming-using-python)
- [📏 UBC - CPSC110 - Systematic Program Design](#-ubc---cpsc110---systematic-program-design)
- [🧪 UW – CSE341 – Programming Languages A, B, & C](#-uw--cse341--programming-languages-a-b--c)
    + [🎾 Perhaps I Was Too Hard on Racket (Bonus Segment)](#-perhaps-i-was-too-hard-on-racket-bonus-segment)
- [♨️ UAlberta - Object-Oriented Design, Design Patterns, & Software Architecture](#%EF%B8%8F-ualberta---object-oriented-design-design-patterns--software-architecture)
- [📚 Design Patterns - Elements of Reusable Object-Oriented Software (Extra Reading)](#-design-patterns---elements-of-reusable-object-oriented-software-extra-reading)

---

# 🚀 Preface
>### *“Who wants to be pulling all-nighters because they can’t find a bug in their program?”*

Is the reason I gave for not studying computer science. I decided to study mechanical engineering instead, as I knew I liked making things and I was good at math and science. While in retrospect, that statement about computer science was naïve, I still believe that mechanical engineering was the correct choice for me. I’ve been satisfied with what I’ve learned, and I’ve acquired lots of skills that will be practical in the future. However, the omnipresence of software in every facet of daily life makes these engineering skills by themselves less useful in isolation. I believe that to truly succeed in today’s world, it is necessary to acquire both engineering and computer science skills.

Many of my hobby projects have focused on some form of software development. Projects centered around web development, game development, graphics programming, and the like have been able to capture my attention for months at a time. Though, most of these projects would follow a similar trend. I would quickly make progress and rapidly learn and apply new programming concepts. However, I would always run into knowledge or skill barriers that I wouldn’t be able to overcome due to my lack of foundational knowledge in computer science. As a result, I would lose motivation for a project and quickly abandon it for my next big interest. These projects were useful for building skills in the short term, but have resulted in my computer science knowledgebase being more akin to pockets of skills rather than a deep understanding of concepts.

Realizing these two ideas﹘The importance of understanding computer science and my lack thereof﹘has given me the necessary drive to self-study computer science. Ironically, not choosing computer science as my major may have been the best thing that has happened to me in regard to computer science. Self-study is advantageous in the fact that I can pace my learning in a way that is appropriate for me, while still getting a complete education. Self-study also forces me to take the initiative to learn rather than being forced to by social expectations or financial pressures. I’m in control of my own success or failure, which is quite satisfying.
### 💼 Career Development
One objective of my continued self-education in computer science has always been to open more career opportunities for myself in the future. My goal is to reach a point where if I chose to, I could shift from an engineering role to a software role, or somewhere in between. The way to do this is to reach a skill level that is competitive with those pursuing an undergraduate degree in computer science. My intentions with Open-Source Society University are thus to provide myself with a self-guided formal education to achieve this goal.
### 🤷‍♂️ What is OSSU?
[Open Source Society University (OSSU)](https://ossu.firebaseapp.com/#/about) provides a path for anyone to self-study computer science. In their own words, OSSU provides “a complete education in computer science” through free online courses from top universities. OSSU emphasizes that their resources are for “those who want a proper, well-rounded grounding in concepts fundamental to all computing disciplines”. The curriculum is designed according to the degree specifications for undergraduate computer science majors.

The courses selected are open for free enrollment and are “of high quality in teaching materials and pedagogical principles”. Courses are only selected if they meet the [Curriculum Guidelines for Undergraduate Degree Programs in Computer Science](https://www.acm.org/binaries/content/assets/education/cs2013_web_final.pdf). If no available online courses meet this criterion, the course is supplemented with online reading. Completion of the OSSU curriculum involves taking around 40 online courses.

_Learn more about Open Source Society University at:_ [ossu/computer-science](https://github.com/ossu/computer-science)
### ⏰ Statement of Commitment
*I intend to commit 20 hours a week, or slightly less than 3 hours every day to learning computer science. This number is intended to be an average, and it is acceptable if the hours I spend on OSSU vary day-by-day. However, I do intend to commit at least 30 minutes every day to this education.*
### ✏️ Fair Use
*I give permission for any person to distribute or share this README article for informational or entertainment purposes only. I do not give permission for this README article to be distributed for monetary gain without my consent. I do not give permission for any person to plagiarize this article or claim it as their own original work.*

---

# 🗃️ How This Repository is Organized
This section provides a brief overview of how the materials in this repository are organized. The content is split into three sections.
#### 👨‍💻 Coursework
This folder contains all the code I have written for courses. This includes the type-along code from lectures and all the homework code I have completed.
#### 📓 Notes
This folder contains all the notes I have written while taking these courses. I use [Notion](https://www.notion.so/product) to type out and save all my notes. I then export them from Notion into PDFs which I upload to GitHub.
#### 📜 Certificates
Certificates of completion for courses I have passed are in this directory. It doesn’t matter to me that some courses don’t offer free certification, as the notes and coursework sections of this repository are sufficient proof of work for them. One of my goals with OSSU is to prove that myself, and anyone else, can self-study computer science *for free*. Therefore, paying for any course certificates would go against this philosophy.

---

#### _One final note: README Updates_
This article is most often updated after completion of each course in the OSSU curriculum. Otherwise, I will usually only update it to fix typos or make wording adjustments. In addition, my opinions are subject to change due to the insights and knowledge I gain from taking new courses. Therefore the README is constantly updated to reflect my current thoughts and feelings.

---

# 🐍 Harvard - CS50 - Introduction to Programming with Python
Start Date: `11/01/2023` ---> End Date: `11/25/2023`
Time | Estimate | Actual
--- | --- | ---
Weeks | 10 | 3.6
Hours | 100 | 41.2
Hours/Week | 10 | 11.5
## 🔙 Retrospective
Part of what makes [Harvard's Introduction to Programming with Python (CS50P)](https://cs50.harvard.edu/python/2022/) so great is Professor David J. Malan’s ability to teach programming concepts clearly and concisely. One problem I've encountered with many teachers is that they assume their students have a certain level of prerequisite knowledge. This can prevent the teacher from fully communicating a topic to their students, due to a lack of parity in implicit knowledge between the students and teacher. Despite his programmer proficiency, Malan has the unique ability to approach computer science from the outside perspective of a programming novice. He stresses incremental code improvement and a reliance on building off of previously taught concepts, and this makes his lectures easily digestible, even for a CS outsider. His high energy and passion during lectures makes learning programming exciting.

Malan uses Python as a tool to teach programming, not to teach Python. This was a sharp deviation from the "Introduction to Programming for Non-Majors" course I took previously at my university. That course's goal was to teach the Python programming language and expected students to learn computer science as a side effect. Unlike that course, CS50P sets students up to extend their learning beyond the Python programming language.
### 💡 What I Learned
Given my previous experience with programming I did not expect to learn much. I was wrong. I found gaps in my knowledge being filled. For example, I now know that function parameters and arguments are two different things. I was surprised that I has gone years without knowing that. It's genuinely impressive how much content is crammed into CS50P’s ten lectures. The topics covered are diverse, practical, and foundational for a further education in computer science. Malan starts by teaching the basics like variables, conditionals, loops, and functions. The content quickly expands to cover APIs, data persistence, regular expressions, and more. Despite the large selection of topics covered, I never once felt overwhelmed by new information. Additionally, the homework was an opportunity to put what was learned in lectures into practice, and never once felt like busy work.
### 👎 Dislikes
My one small nitpick is that the lectures are not a consistent length. Lectures lengths vary from less than an hour to almost three hours.
### 🤔 Suggestions for Students
Don’t be afraid to pause the lectures and go slow. You will learn much more if you code along with Malan during lectures and take notes. Conversely, don’t be afraid to go off the rails and try to predict what Malan will code if you feel confident. One great thing about this course is that it encourages you to learn through experimentation.
## 🔑 *Key Takeaways*
* Part of good programming is trying to find a balance between elegance and readability.
* Don’t try to write a program all at once. Incremental progress is important for catching bugs in one’s code and improving it over time.
* Testing code with unit tests is important for confirming that the outputs of a function stay constant, even if the code in the function body is refactored.

---

# 👨‍💻 MIT - 6.0001 - Introduction to Computer Science and Programming using Python
Start Date: `11/28/2023` ---> End Date: `12/17/2023`
Time | Estimate | Actual
--- | --- | ---
Weeks | 9 | 3
Hours | 135 | 26
Hours/Week | 15 | 8.7
## 🔙 Retrospective
[MIT's Introduction to Computer Science and Programming using Python](https://ocw.mit.edu/courses/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/) main strength is that the topics it chooses to cover are examined in high detail. Topics that are previously covered in <Components.InternalLink to="/articles/introduction-to-programming-with-python/">Harvard's CS50P</Components.InternalLink> like string manipulation and object-oriented programming are broken down from the perspective of a computer scientist rather than a programmer. This decision to approach problems from both a theoretical and applied perspective allows one to deeply understand each topic, no matter what programming language is being used. My favorite lectures in the course were, by far, those taught by Professor Eric Grimson. He has a confident, well-paced lecturing style that I really enjoyed listening to. His lectures also tended to cover topics that were not covered in CS50P.
### 💡 What I Learned
Where this course really shines is its lectures on recursion, data structures, algorithms, and program efficiency. Before this course, I had no experience writing a recursive programs. I learned that the implementation of a program is very important in deciding its efficiency. Choosing to implement an algorithm iteratively or recursively can result in a large difference in the time complexity of a program. I now understand its purpose for analyzing the complexity of algorithms in relation to their inputs.

I really enjoyed working on the problem sets. Each problem set was a great way to apply what I had learned up to that point. Each problem set was designed around building a complete and useful program. Knowing I was working towards a complete and useful program helped motivate me.
### 👎 Dislikes
In my opinion, this course was difficult to get into. I attribute part of this difficulty to the fact that the course I took prior to this one, Harvard's CS50P, was so great. This course repeats a lot of the same topics covered in CS50P, but with less energy. Dr. Ana Bell, while obviously very knowledgeable of the lecture material, is not the most engaging teacher in my opinion.

Additionally, there are very few opportunities during lectures to program along with the professor. This causes the learning to feel very disjointed, since you are digesting a lot of information and not coding during the lectures, and then coding a lot during the problem sets.
### 🤔 Suggestions for Students
Like most online courses, take the time to pause or slow down lecture if you feel that the Professor is going too fast. Additionally, be aware that most of the homeworks will take a long time. I usually split my work on each one up across multiple days.
## 🔑 *Key Takeaways*
* Computer science and programming are not synonyms.
* It is important to analyze an algorithm separately from its implementation in code, or the machine that implementation is being run on.
* Order of growth (Big O) notation measures the *worst case* upper bound of the asymptotic growth of an algorithm in terms of its input.
* Recursion is a useful method for implementing algorithms, and has many advantages and disadvantages when compared to iteration.

---

# 📏 UBC - CPSC110 - Systematic Program Design
Start Date: `12/25/2023` ---> End Date: `01/03/2024`
Time | Estimate | Actual
--- | --- | ---
Weeks | 13 | 1.5
Hours | 104-130 | 54.8
Hours/Week | 8-10 | 36.5
## 🔙 Retrospective
Before taking this course, I assumed that a skilled intuition for designing programs could only be developed though exposure and practice. Professor Gregor Kiczales' instruction in [Systematic Program Design (CPSC110)](https://learning.edx.org/course/course-v1:UBCx+SPD1x+2T2015/home) has managed to convince me otherwise. During the course, Kiczales shows how simple design techniques can be built upon one another to write functions for increasingly complex programs. He constantly expresses the importance of learning by doing and encourages students to work ahead of him to prove their growing intuition for program design. At first, I disliked the course's slow pacing. Over time however, I came to realize that this slow pace allows him to methodically step through the thought-process needed for designing functions. CPSC110 emphasizes the importance of working through the design process correctly rather than quickly.

My only exposure to Racket before taking this course was listening to my CS/DS-major friends complain about how terrible it is. After heavy exposure to the language myself, I can't say I disagree. However, I did find that Racket excels at teaching systematic program design. Racket’s simplicity compared to other programming languages forces you to start from first principles and not rely on higher-level program abstractions to solve problems. Consequently, barely more than a single lecture is spent getting comfortable with Racket, which allows students to focus less on the language and more on systematic program design.
### 💡 What I Learned
This course is valuable in the fact that it teaches students to design programs in a **systematic** manner. You are first taught the best practices to convert real world information into data definitions implemented in code. Kiczales details how these "data definitions" can be used to create templates for functions that operate on those data definitions. At first I was skeptical that these templates were a one-size-fits-all skeleton for any function. Despite my skepticism, the course proves through example that these templates can be adapted to any function necessary. Although it is not shown in the course, the systematic program design process is built on top of a very solid foundation of computer science theory. CPSC110's goal is, as Kiczales says, to break program design down to a science, rather than typing code and hoping for the best.
### 👎 Dislikes
The DrRacket IDE is slow and gaudy, and many keywords in the Racket language are oddly cryptic. Writing a "big bang" function for my "world program" was just one of many cases where I pondered if Racket's developers thought it more important to be unique than practical. In addition to this, every expression in Racket is enclosed in parentheses. This came to its natural conclusion when I found myself nesting up to eight sets of parentheses for a program. Although this issue can be partially remedied by careful and consistent indentation, excessive parentheses makes the program design process a nightmare. I believe that the onus for designing readable code should fall on the designer(s) of a language's syntax first and foremost. Programmers should not be limited by a programming language when trying to write readable code.

>While I still believe that programming languages design should prioritize readability, my opinions about Racket have changed significantly after taking the [University of Washington Seattle’s Programming Languages](#-uw--cse341--programming-languages-a-b--c) course. You can read my updated thoughts on Racket in  [🎾 Perhaps I Was Too Hard on Racket (Bonus Segment)](#-perhaps-i-was-too-hard-on-racket-bonus-segment)

Another major gripe with the course is that the final project is off-limits to students that do not follow the paid track. I would have liked the opportunity to use the skills I developed through the second half of the course in a cumulative exercise. Fortunately, the practice problems and midterm project are available for free, so I don't feel that I missed out on much.
### 🤔 Suggestions for Students
Get comfortable using recursion. A purely functional programming language means no iteration, which means that you need to build a deep understanding of recursive programming to succeed.
## 🔑 *Key Takeaways*
* Systematic design uses higher-level design concepts to break down complicated problems to a point where one can solve them simply.
* Identifying the structure of information in a problem is a key step in program design.
* Unit tests should be made before writing the body of a function, as this gives you concrete examples for what a function should output.
* Given a base case, trust that the natural recursion in a program will work as expected.
  
---

# 🧪 UW – CSE341 – Programming Languages A, B, & C
Start Date: `01/04/2024` ---> End Date: `02/03/2024`
Time | Estimate | Actual
--- | --- | ---
Weeks | 11 | 4
Hours | 44-88 | 90
Hours/Week | 4-8 | 22.5
## 🔙 Retrospective
“[Programming Languages](https://www.coursera.org/instructor/~87326)” is quite a misleading course name, since the focus of the course is not on the syntax of different programming languages, but the semantics and idioms that they all share. It is repeatedly emphasized that the focus of the course is not on the programming languages used (Standard ML, Racket, and Ruby). Instead they are conduits to understand the more foundational aspects of programming languages. Professor Dan Grossman’s extensive knowledge of programming languages, paired with his dry humor, makes this course’s lecture videos a pleasure to work through. His lectures “pull back the curtain” on programming constructs to understand them at their most basic level. It is extremely interesting to see how all programming languages, at their core, can be broken down into their semantics, type checking rules, and evaluation rules. For example, ML and Ruby are compared against each other to understand the differences between statically and dynamically typed languages, and functional and object-oriented languages. Over time, ideas are compounded such that they can be used to compare new concepts that are brought up. This makes for a course that, seems shallow in its content at first, but makes for some satisfying realizations later on.

I’ve found that this online course is the most challenging one I’ve taken so far. The homework is exacting in the sense that you have to read and follow the requirements very carefully to receive a satisfactory grade. In addition to the complex homeworks, there are three exams to test your knowledge of the course material. This is different from the previous courses I’ve taken which ask you to apply your knowledge with homeworks, but do not test it any further beyond that. You must get an 80% or higher on homeworks and exams in order to access further course material. By the end, this makes the student feel much more accomplished with their completion of the course. Grossman is extremely aware of the accomplishments of those who are able to complete the course and satisfyingly acknowledges the many hours of work students invest into completing it.
### 💡 What I Learned
The most important idea that Grossman draws attention to is that programming languages are only interfaces for writing software. Programming language semantics, seperate from the language's syntax, are more important since those are the rules that determine how a program behaves. The homeworks are built in a way to apply and challenge your knowledge of these semantics. For example, I found the programming construct of “thunks” extremely difficult to understand. It was only when I was asked to use them in a homework, that I was forced to take the time to understand properly.

This may seem obvious. Of course you need to understand the concepts utilized in a homework to do well on it. However, these homeworks are complex enough so that by the time you finish the homework, you feel like you have learned something rather than having just scrapped by. This is especially important since much of the content in this course is naturally cumulative, and as a result you will retain the knowledge needed to tackle problems where past concepts are revisited.

My favorite learning experience was from what is touted as the most challenging homework. This homework's goal is to write a made-up programming language interpreter. This homework was remarkably effective for strengthening my understanding of interpreters, and it really felt like an application of my cumulative course learning. The implementation of a target language ("MUPL") using a metalanguage (Racket) was a great way to understand what goes on under the hood of many programming languages. It reshaped my entire understanding of how functions are evaluated, and made the differences between functions, closures, and environments clear to me. It was also important for understanding how an interpreter error-checks a dynamically typed language.
### 👎 Dislikes
Unfortunately, the image of Grossman jumping up and down, clapping his hands, telling me that "subtyped function arguments are contravariant" is still burned into my brain.
### 🤔 Suggestions for Students
This is a challenging course. Make sure you understand the lecture material, or you will not pass the homework or exams. Take time to understand each language construct and how they work together to create more complex behavior.
## 🔑 *Key Takeaways*
* All programming language behaviors are the result of semantics, type checking, and evaluation rules.
* Syntax is just an interface for writing software.
* Often, strictly compiled or interpreted, statically or dynamically typed, and functional or object-oriented programming languages do not exist, and most programming languages sit on a spectrum between these hard definitions.
* An environment is simply a mapping from variable names to values.
* The purpose of software is to take simple language constructs and combine them with human ingenuity to create complex systems.


## 🎾 Perhaps I Was Too Hard on Racket (Bonus Segment)
<img src="https://imgs.xkcd.com/comics/lisp_cycles.png"
     alt="XKCD 297"
     style="margin-right: 10px;" />
>##### *From xkcd.com – "Lisp Cycles (297)"*
### Parentheses are Good, Actually
One construct discussed in [Programming Languages](#-uw--cse341--programming-languages-a-b--c) is the abstract syntax tree (AST). ASTs are essentially a graph representation of how a language interpreter breaks down a program into smaller components, which are evaluated based on their syntax. Racket’s parentheses are highly meaningful, as each pair of parentheses essentially represents one node in an AST, and the separate expressions contained in those parentheses are different branches off of that node. This heavy usage of parentheses makes Racket a great metalanguage to implement other programming languages in, since the interpreter for the target language would simply be a recursive Racket function.

Homework five of Programming Languages has the student create a made-up programming language (aptly named MUPL) using Racket as the metalanguage. This homework is deeply fulfilling since it applies many of the cross-lecture concepts taught in Programming Languages, and provides a better understanding of interpreters among other things. Racket makes building the MUPL interpreter a process of concrete steps, because each evaluation step is roughly equivalent to an expression in the target language wrapped in parentheses. Dan Grossman’s in-depth analysis of Racket’s semantics gave me a much greater appreciation for the programming language than I did before.
### Would I Use Racket?
I think that Grossman put it most succinctly by saying that:
>*“…[one] is entitled to [their] opinion about syntax, but a good historian wouldn’t refuse to study a country where they didn’t like people’s accents."*

At the end of the day, a programming language is an interface for writing software. The choice to use Racket would depend entirely on if it were the best tool for the job. I’ve learned that part of being a good computer scientist is exploring technologies outside of your comfort zone, and discovering new tools you might actually enjoy using.

---

# ♨️ UAlberta - Object-Oriented Design, Design Patterns, & Software Architecture
Start Date: `02/10/2024` ---> End Date: `03/08/2024`
Time | Estimate | Actual
--- | --- | ---
Weeks | 12 | 4
Hours | 40-52 | 36.5
Hours/Week | 3.3-4.3 | 9.1
## 🔙 Retrospective
[Object-Oriented Design](https://www.coursera.org/learn/object-oriented-design), [Design Patterns](https://www.coursera.org/learn/design-patterns), and [Software Architecture](https://www.coursera.org/learn/software-architecture) are the first three parts of a four-part collaborative course between Coursera and the University of Alberta. This course has many qualities that just don’t work in my opinion, leading to a result that is mild at best. I really, *really* tried to find good qualities of this course, but by the end I just couldn't.

This course prioritizes breadth over depth. Important topics are often condensed into ten-minute-long videos, where only surface level details are covered. Many of these details are reiterated to the point where dialog feels more redundant than reinforcing. I don’t have enough digits on my hands and feet to count how many times *“XYZ will make your code more reusable, flexible, and maintainable”* was said ad nauseam. These shallow lectures and lack of hands-on work left me extremely unsatisfied.
### 💡 What I Learned
Because this course is composed of three sub-courses, I will discuss what I learned from each course separately.

*Object-Oriented Design*

Object-Oriented Design (OOD) covers some of the team-based, non-programming skills related to software development. For outsider to the discipline, the course provides insight into how software development teams work together to design software systems in a business environment. Design tools like UML diagrams are covered. These diagrams are used to plan out software systems before any implementation work is done. I learned [Mermaid JS](https://mermaid.js.org/), a UML diagramming tool, so I could practice making these diagrams. The principles of object-oriented programming: abstraction, encapsulation, inheritance, and polymorphism, are covered extensively. These principles, along with coupling and cohesion, are introduced in Object-Oriented Design and are repeatedly applied in later parts of the course.

*Design Patterns*

Design Patterns was by far the most interesting and useful of the three parts of the course. Creational, structural, and behavioral design patterns are discussed in sufficient detail. These design patterns are extremely useful to be aware of when working with the object-oriented programming paradigm. Design Patterns covers the problems associated with each design pattern, and how those problems can be addressed by using them in conjunction with other design patterns. This emphasizes how design patterns are not mutually exclusive and can be used in combination to design more effective software systems. It’s also interesting to consider how these design patterns arise from different OOD principles like the open/closed principle, dependency inversion, etc. Anti-patterns are covered, but in lesser detail.

Even still, Design Patterns has its flaws. It's odd that they discussed the design principles *after* describing design patterns. Since many design patterns naturally arise as solutions to object-oriented design principles, I think it would have been useful to know these principles beforehand to give better context for the design patterns. Additionally, this course only covers around half of the design patterns outlined in [the gang-of-four book](#-design-patterns---elements-of-reusable-object-oriented-software-extra-reading). It’s frusturating that they exclude the other ten or so design patterns, and it felt like the course was cut short right when the content was starting to get interesting. Like with most aspects of this course, Design Patterns settles for good enough.

*Software Architecture*

Software Architecture’s main purpose is to look at different system architectures, and assess their use cases, advantages, and disadvantages. The most interesting part of this course, in my opinion, was seeing different architectures that I was aware of in an abstract sense sorted into concrete categories. It was one of the only parts in this three-part course where anything really “clicked” for me. It gave me a whole new perspective on the design choices for lots of software and programs I’m already familiar with.

This part of the course involves absolutely zero programming, which makes learning through doing impossible. There is a lot of jargon thrown around carelessly, and the second half of Software Architecture feels more like a business course than a computer science course. However, this isn’t the worst thing, as it’s important to understand software in the context of a business. One knows that it’s important to identify quality attributes so you can pivot strategies and not move the project goalposts too far, <sub>resulting in having to circle back later.<sub> These topics have lots of moving parts <sub> and I don’t expect the instructors to <sub>be giving me <sub>their 110%...</sub></sub></sub></sub></sub> 😴
### 👎 Dislikes
Someone decided that the best teacher would be a theater major reading from a teleprompter. I'd prefer to have been taught by someone who knows what they're saying, but I guess we can't always have what we want. Listening to someone read from a script with feigned enthusiams for hours is a soul-crushing experience, and is one of my main arguments for why this course fails to teach effectively. Courses are elevated from good to great when they are taught by someone that deeply understands the topics they are teaching. This gives the course several qualities. Most importantly, the instructor can emphasize the importance of ideas and elaborate on them. The failure of this course's lecturer to extract meaning from the words they are saying is what prevents this course from being engaging. [This quote from the GitHub user Ahsatan](https://github.com/ossu/computer-science/issues/1168) sums the matter up best in my opinion:

>*"The tedium of watching somebody who clearly doesn't care about the topic and can't pronounce 'Java' nor 'attributes' was infuriating. Passion is so valuable towards engaging your audience and this class falls flat after the previous courses I’ve taken."*

Of course I don’t blame the person reading from the script, they’re just doing their job. I blame the course's creators for (1) making the course read verbatim from a script and (2) choosing someone inexperienced in software design.

There are, on occasion, times where what is being said makes no sense. This is the result of typos in the script, and the script reader having no idea what they are saying. I liken it to how a generative AI can halluciante utter nonsense with complete confidence.

One thing this course loves to throw around is similes. This design pattern is like an automatic coffee maker. This software architecture is like a water treatment facility. This separation of concerns is like the students and teachers at a school. I agree that comparisons are a great way to introduce students to a new concept, since they can compare it to something they are already familiar with. The problem arises when a student becomes reliant on that comparison to understand the new concept. It reminds me of how circuits are taught to first-year engineering students. Because electricity can be abstract and difficult for lots of people to understand, electrical components and circuit properties are introduced using fluid flow comparisons. For example, voltage is like the pressure differential in a pipe, and therefore batteries are like pumps that create a voltage differential in the circuit. Object-Oriented Design, Design Patterns, and Software Architecture are the electrical engineering course that never abandons these analogies for a more fundamental understanding of electricity and circuits, if you get what I mean.
### 🤔 Suggestions for Students
Honestly, I want to say don’t bother with this course. If you do bother, I suggest that you follow the free track and take good, thorough notes on the lectures. Don’t bother with the capstone project, as the documentation is outdated and the work in Android Studio is beyond the scope of the course.
## 🔑 *Key Takeaways*
* Diagramming a software system makes spotting flaws and inconsistencies in that software system much easier.
* Design patterns are conventionalized program structures to solve common design issues.
* The quality of software architecture is determined by how well it addresses the requirements for a specific use case in a specific environment, and therefore software architecture cannot be labelled as strictly “good” or “bad” without context.

---

# 📚 Design Patterns - Elements of Reusable Object-Oriented Software (Extra Reading)
<img src="https://programmerhumor.io/wp-content/uploads/2023/03/programmerhumor-io-programming-memes-83d346868e68a1f.jpg"
     alt="Let's take the complexity, an dput it somewhere else"
     style="margin-right: 10px;" />
>##### *From the ProgrammerHumor Subreddit, "The Evolution of Design Patterns"*
### 🔇 What I Won't Talk About
I'll begin saying that my intention isn't to cover each design pattern present in [Design Patterns](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612), along with their implementations. That's what the book does. If you want to learn each design pattern in detail, read the book. Instead, I'll be focussing on the general ideas that span the entire book. I'm going to share what key design principles I learned, what I found interesting, and how well I think this book holds up after nearly 30 years since its publication.

### 🦕 A Time Before Java
The most significant obstacle Design Patterns needs to overcome is staying relevant to a modern reader. Most implementation code in this book is written in C++, with a smaller amount written in Smalltalk. Smalltalk, although not part of the current popular programming languages zeitgeist, is still used in industry. C++, of course, remains relevant to this day.

But why doesn't this book use Java, the most popular object-oriented programming language of all time? Design Patterns was published in 1994, or 30 years ago at the time I'm writing this. Those who are more atune than I with the history of programming languages would know that Java was released in 1995. Therefore there is no Java code in the book. If there was, I could have added that to my list of "evidence to support the existence of time travellers", which remains empty.

Although the date this book was publish is mostly unconsequential to the overall goal is succeeds achieving, there is one area where its age shows. Many of the case studies examine softwares are largely irrelevant nowadays. If you can tell me what Motif, Presentation Manager, or Unidraw are, you're probably old enough to remember the collapse of the Soviet Union. Of course the authors had no way of knowing these softwares would fall out of fashion. Though, because the softwares are unfamiliar, it is sometimes difficult to understand what problems in the software certain design patterns solve.

### 🤓 Why Design Patterns are Important
Design patterns are software abstractions one level above classes and objects. The book argues that "composition at the pattern level rather than the class or object levels lets us achieve the same synergy with greater ease" (349). Viewing a program as a system of interconnected design patterns rather than a system of interconnected classes and objects saves time and effort by removing the need to "...solve every problem from first principles" (1). One wouldn't start designing an object-oriented program by implementing their own definition of classes and objects, so why should one do the same with design patterns? The fundamental reason for design patterns is to avoid the work required to rediscover this higher abstraction level.

In fact, just being aware of design patterns helps one reason about software systems more like an expert. What separates an expert from a novice is the ability to design a software system that is flexible and maintainable while minimizing the manpower, time, and cost needed to create that system. The authors of Design Patterns say that the reason they chose the word *design* patterns is because "...they make programs more resistant to re-*design* and refactoring" (353). Being able to create an effective system design from these design patterns is what allows for easy code refactoring, and saves time, money, and effort in the long run.

### ✌️ The Two Principles of Object Oriented Design
Design Patterns outlines two principles of object-oriented design, those being: (1) program to an interface, not an implementation, and (2) favor object composition over class inheritance. Following these two principles closely generally results in the separatation of the complexity of a behavior from its class or object.

*Program to an interface, not an implementation*

The majority of inheritance in design patterns is strictly single inheritance. In fact, it is very rare to find a subclass of a subclass in this catalog. The reason for this is that anything more than single inheritance often results in a class relationship that is too dependent on its compile-time structure to make a software system sufficiently flexible. The main use case for single inheritance is having one or more concrete classes inherit from an abstract class so that they share a common interface. As a result, all classes or objects which interact with the design pattern are easily decoupled from the class heirarchy.

*Favor object composition over class inheritance*

Since anything more than single inheritance is actively discouraged, Design Patterns suggests that object composition should be used wherever possible over subclassing. Like single inheritance, object composition helps decouple software systems. The major difference between these two approaches is that object composition allows object interactions to be dynamic at run-time, where class relationships are fixed at compile-time.

Object composition is not perfect though, since its main advantage also comes at a cost. While single inheritence prevents individual classes from growing too complex and becoming "monolithic", object composition can inadvertantly lead to the opposite occuring. For example, the Mediator* pattern's internal cohesion is inversely proportional to the number of colleague objects it interacts with. This book studies how to decrease coupling between objects in great detail, but often glosses over methods to prevent low cohesion within an object. Of course there is discussion about single responsibility, and how to maintain high cohesion during implementation, but this information is not extensive enough in my opinion.

This book warns the reader to keep the balance between complexity and indirection in mind when adding design patterns to a software system. Design patterns achieve reduced system complexity primarily through code indirection. Although indirection can makes code more reusable, it can also make a program difficult to understand. Therefore if a design pattern's use does not create more flexibility, maintainability, or reusablility in a software system, its addition is counterproductive.

<sub>*Any common noun capitalized as proper noun means it is a pattern from the Design Patterns catalog.</sub>

### 🤔 Things to Think About
After reading this book I'm more skilled in spotting design patterns in programs I interact with. For example, I now recognize that the [React library](https://react.dev/) relies on the Composite pattern to structure components, and uses the Template pattern for its hooks. To anyone reading this article in 2054, I apologize for using such an a outdated framework as an example.

Similarly, there were many times when concepts that I'm familiar with were presented in a new, object-oriented way. Before reading this book, I was familiar with interpreters and how they operate on abstract syntax trees in the context of functional programming. But in the object-oriented world, an Interpreter pattern operates on an abstract syntax tree which, in the context of object-oriented programming, is a Composite pattern. I find it really neat how design patterns can intuitively recreate the structure and behavior of familiar ideas within the limits of the object-oriented design space.

The authors say that "...the theme of many design patterns..." is "...**encapsulating the concept that varies**..." (29). The table on page 30 lists what design aspect varies for each design pattern. In my opinion, this table holds the most concise description of each design pattern. I would argue that this tables describes some patterns better than their intent (summary) sections in catalog. As a novice, referencing this table from time to time helped me gain a better understanding of what problem each design pattern is intended to solve. This provides merit to the idea that the variant behavior of a design pattern is fundamental to its identity and use cases.

While this book provides a catalog of *object-oriented* design patterns, the authors acknowledge that it is not a comprehensive list. Design Elements prompts the reader to "look for patterns you use, and... make them part of your documentation" (358). They say that this book is also an invitation to "explore the [larger] space of design patterns" (356), not just the one exclusive to object-oriented systems. Rather than providing a fixed guide for implementing reusable software, their primary goal is to equip the reader with the know-how to recognize what design choices lead to more reusable software.

---

### README Changelog
Date | Changes
--- | ---
November 25, 2023 | <ul><li>**ADDED**<ul><li>Preface</li><li>Harvard - CS50 - Introduction to Programming with Python</li></ul></li></ul>
December 25, 2023 |  <ul><li>**ADDED**<ul><li>Table of Contents</li><li>MIT - 6.0001 - Introduction to Computer Science and Programming using Python</li></ul></li><li>**REVISED**<ul><li>Preface</li><li>Harvard - CS50 - Introduction to Programming with Python</li></ul></li></ul>
January 03, 2024 | <ul><li>**ADDED**<ul><li>UBC - CPSC110 - Systematic Program Design</li></ul></li></ul>
February 08, 2024 |  <ul><li>**ADDED**<ul><li>What is OSSU?</li><li>How This Repository is Organized</li><li>Programming Languages<ul><li>Perhaps I Was Too Hard on Racket (Bonus Segment)</li></ul></li></ul></li><li>**REVISED**<ul><li>Preface</li>Systematic Program Design</li></ul></li></ul>
March 09, 2024 | <ul><li>**ADDED**<ul><li>UAlberta - Object-Oriented Design, Design Patterns, & Software Architecture</li></ul></li></ul>
April 07, 2024 | <ul><li>**ADDED**<ul><li>Design Patterns - Elements of Reusable Object-Oriented Software (Extra Reading)</li></ul></li><li>**FIXED**<ul><li>Table of Contents</li></ul></li></ul>
May 19, 2024 | <ul><li>**REVISED**<ul><li>Fixed typos, grammar, and improved general article structure</li></ul></li></ul>
