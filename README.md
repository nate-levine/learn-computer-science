# learn-computer-science
A formal computer science education through Open Source Society University.  

_Learn more about Open Source Society University at:_ [ossu/computer-science](https://github.com/ossu/computer-science)
# 🧭 Table of Contents
- [🚀 Preface](#preface)
    + [💼 Career Development](#career-development)
    + [⏰ Statement of Commitment](#statement-of-commitment)
    + [✏️ Copyright](#copyright)
- [🐍 Harvard - CS50 - Introduction to Programming with Python](#harvard---cs50---introduction-to-programming-with-python)
  * [🔙 Retrospective](#retrospective)
  * [🔑 *Key Takeaways*](#key-takeaways-)
- [👨‍💻 MIT - 6.0001 - Introduction to Computer Science and Programming using Python](#mit---60001---introduction-to-computer-science-and-programming-using-python)
  * [🔙 Retrospective](#retrospective-1)
  * [🔑 *Key Takeaways*](#key-takeaways--1)
- [🧪 UBC - CPSC110 - Systematic Program Design](#ubc---cpsc110---systematic-program-design)
  * [🔙 Retrospective](#retrospective-2)
  * [🔑 *Key Takeaways*](#key-takeaways--2)

---

# 🚀 Preface
When I was in high school, I wasn’t sure if I wanted to major in mechanical engineering or computer science. By junior year, I decided mechanical engineering was the right choice because I didn't *“want to be up until 4:00am trying to find a bug in my code”*. While, in retrospect, that statement was naïve, I still believe that mechanical engineering was the correct choice. However, I’ve routinely wondered how my college career would have played out differently if I had chosen computer science.  

A large chunk of my free time during college has been working on computer science passion projects. This meant learning full-stack web development, JavaScript frameworks, game development, graphics programming, etc. These projects were useful for building skills in the short term, but due to my lack of foundational knowledge none of these skills ever stuck fully. This has resulted in a knowledgebase that is more akin to haphazardly placed support beams than a concrete foundation.
### 💼 Career Development
This all came to ahead about a month ago (October 2023 as I’m writing this) when I started to apply to internships for the summer before my senior year of college. One objective of my continued self-education of computer science has always been to open more career opportunities for myself in the future, specifically in CS. This means that if I chose to, I could shift from an engineering industry to a software industry, or some adjacent field. Applying to software engineering internships has made me realize that I don’t possess all the skills to meet the criteria for these roles.

I decided that the best course of action would be to pad out my foundational knowledge and skills, learn about more advanced topics in CS, and reach a skill level that is competitive with those pursuing a Bachelor's degree in CS. My intentions with Open-Source Society University are to provide myself with a self-guided formal education to achieve these goals.
### ⏰ Statement of Commitment
*I intend to commit 20 hours a week, or slightly less than 3 hours every day to learning computer science. This number is intended to be an average, and it is acceptable if the hours I spend on OSSU vary day-by-day. However, I do intend to commit at least 30 minutes every day to this education if possible.*
### ✏️ Copyright
*I give permission for any person to distribute or share this README article for informational or entertainment purposes only. I do not give permission for this README article to be distributed commercially or for monetary gain without my consent. I do not give permission for any person to plagiarize this article or claim it as their own original work or intellectual property. Any infringement of these rules will not be tolerated.*

---

# 🐍 Harvard - CS50 - Introduction to Programming with Python
Start Date: `11/01/2023` ---> End Date: `11/25/2023`
Time | Estimate | Actual
--- | --- | ---
Weeks | 10 | 3.6
Hours | 100 | 41.2
Hours/Week | 10 | 11.5
## 🔙 Retrospective
Part of what makes Harvard's Introduction to Programming with Python so great is Professor David J. Malan’s ability to teach programming concepts clearly and concisely. One problem I have encountered with many teachers is that they assume their students have a certain level of prerequisite knowledge. This prevents the teacher from fully communicating a topic to their students, due to a lack of parity in implicit knowledge between them and their. Malan has the unique ability to approach computer science from the outside perspective of a programming novice, despite his own expert proficiency with computer science. His stress on incremental improvement of code and reliance of building off of previously taught concepts make his lectures easily digestible even from a CS outsider. His high energy 💥 and passion during lectures made me more excited to learn programming than I have been in a long time.  

Malan uses Python as a tool to teach programming, not to teach Python. Python is treated as a medium to learn programming concepts, and the language is taught along the way as a side effect. This was a sharp deviation from the Introduction to Programming for Non-Majors course I took at my university. That course tunnel-visioned on the Python language and expected the student to learn programming concepts along the way. CS50 was able to teach me much more than that course could, to a greater effect, despite CS50 being online and asynchronous.
### 💡 What I Learned
Given my previous experience with programming I did not expect to learn much (I was wrong). I routinely found myself learning new concepts and having gaps in my knowledge filled. For example, I now know the difference between function parameters and arguments (Yes, really). I was genuinely surprised by how much content is crammed into the course’s 10 lectures (And three mini-lectures). The topics covered are diverse, practical, and foundational for a further education in computer science. Malan starts by teaching basics like variables, conditionals, loops, and functions. The content quickly accelerates to cover APIs, data persistence, regular expressions, and so on. Despite the large selection of topics covered, I never once felt overwhelmed by new information. In addition, the homework felt like an opportunity to put what was learned in class into practice rather than busy work.
### 👎 Dislikes
My one, probably unfair, nitpick is that the lectures are not a consistent length. Lectures vary from less than an hour to three hours in length.
### 🤔 Suggestions for Students
Don’t be afraid to pause the lectures and go slow. You will learn much more if you code along with Malan during lectures and take notes on important points. Conversely, don’t be afraid to go off the rails and try to predict what Malan will write if you feel confident. One great part of this course is that it encourages you to learn through experimentation.
## 🔑 *Key Takeaways*
* Part of good programming is trying to find a balance between compactness and readability.
* Don’t try to write a program all at once. Incremental progress is important for catching bugs in one’s code and improving it over time.
* Testing code with unit tests is important to confirm that the overall functionality of a function doesn’t change, even if the code inside the function does change.

---

# 👨‍💻 MIT - 6.0001 - Introduction to Computer Science and Programming using Python
Start Date: `11/28/2023` ---> End Date: `12/17/2023`
Time | Estimate | Actual
--- | --- | ---
Weeks | 9 | 3
Hours | 135 | 26
Hours/Week | 15 | 8.7
## 🔙 Retrospective
MIT's Introduction to Computer Science and Programming using Python has advantages in the fact that the topics it chooses to cover are examnied in high detail. Topics that are previously covered in Harvard's CS50 like string manipulation and OOP are broken down from the perspective of a computer scientist rather than just a programmer. This decision to approach problems from both a theoretical and applied perspective allows one to deeply understand each topic, no matter what programming langauge or implementation is being used. My favorite lectures, by far, were those from Professor Eric Grimson. He has a confident, well-paced lecturing style that I really enjoyed listening to. Unlike Professor Ana Bell's lectures, his lectures tended to cover subjects matter that was not covered in CS50.
### 💡 What I Learned
Where this course really shines is its lectures on recursion, data structures, algorithms, and program efficiency. Before this course, I had no experience writing a recursive program. I had heard mentions of recursion in passing and believed that it was more of a stylistic choice for programs that anything else. However, through 6.0001 I learned that the implementation of a program is very important in deciding its efficiency. Choosing to implement an algorithm iteratively or recursively can result in a large difference in the time complexity for a program. I had also heard of order of growth notation in passing, but never really understood it. I now understand its purpose for analyzing the complexity of algorithms in relation to their inputs. This tool will be an extremely useful in the future for analyzing my programs' time efficiency.

I really enjoyed working on the problem sets. Each one was a great way to apply what one had learned up to that point. Each problem set was designed around building a complete and useful program, so that each time I was working towards a concrete goal. The clear, well laid out function skeletons with docstrings meant that I was never confused about how to proceed through a problem, while also leaving the implementation details of a program for myself to figure out.
### 👎 Dislikes
In my opinion, 6.0001 was difficult to get into. I attribute part of this difficultly to the fact that the course I took prior to this one, Harvard's CS50, was so great. 6.0001 repeats a lot of the same topics covered in CS50, but with less energy. Dr. Ana Bell, while obviously very knowledgable of the lecture topics, is not the most engaging teacher in my opinion.

Additionaly, there are very few opportunities during lectures to program along with the professor. This causes the learning to feel very disjointed, as you are digesting a lot of information and not coding during the lectures, and then coding a lot during the problem sets.
### 🤔 Suggestions for Students
Like most online courses, take the time to pause or slow down the playback speed of the lecture if you feel that the Professor is talking too fast. I found this especially important for this course since many of the lecture slides were sped through or skipped entirely. I had a tab open on the side with the lecture slides to remedy this. Additionaly, be aware that the problem sets (with the exception of problem set 0) will take a long time. I ended up splitting my work on them up over the course of multiple days.
## 🔑 *Key Takeaways*
* Computer science and programming are not synonyms.
* It is important to analyze an algorithm separately from its implementation in code, or the machine it is being run on.
* Order of growth, or "Big O", notation measures the *worst case* upper bound on the asymptotic growth of an algorithm in terms of its input.
* Recursion is a useful method for implementing algorithms that has many advantages and disadvantages compared to iteration.

---

# 🧪 UBC - CPSC110 - Systematic Program Design
Start Date: `12/25/2023` ---> End Date: `01/03/2024`
Time | Estimate | Actual
--- | --- | ---
Weeks | 13 | 1.5
Hours | 104-130 | 54.8
Hours/Week | 8-10 | 36.5
## 🔙 Retrospective
Before taking this course I assumed that a skilled intution for designing programs could only be developed though exposure and practice. Professor Gregor Kiczales' instruction in CPSC110 has managed to convince me otherwise. During the course, Kiczales shows how simple design techniques can be built upon one another to write functions for increasingly complex programs. He constantly expresses the importance of learning by doing, and encourges students to work ahead of him to gain an intuition for program design on their own. At first, I disliked the course's slow pacing. Over time however, I came to realize that this slow pace allows him to methodically step through the thought-process needed for designing functions. CPSC110 emphasizes the importance of working through the design process correctly rather than quickly.

My only exposure to Racket was listening to my CS- and DS-major friends complain about how terrible it is. After heavy exposure to the language myself I can't say I disagree, but did I find that Racket excels at teaching systematic program design. The almost laughable simplicity of the Racket programming language forces you to start from first principles and not rely on higher-level program abstractions to solve problems. This benefits in the fact that barely more than a single lecture is spent getting comfortable with the language, which allows students to focus on the important part of the course, program design.
### 💡 What I Learned
This course is valuable in the fact that it teaches students to design programs in a, well, systematic manner. It first steps through converting real world information into data definitions implemented in code. Kiczales details how these "data definitions" can be used to create templates for functions that operate on those data definitions. I will admit that at first I was skeptical that these templates were a one-size-fits-all skeleton for any function. Despite my skepticism, it is proven through example that these templates are able to be adapted to any function necessary. Although it is not explicitly shown in the course, it is stated that the systematic program design process is built on top of some pretty solid computer science theory. I was also introduced to the process of function design, where an algorithm is taken from a signature and purpose to a working function. CPSC110's goal is, as Kiczales says, to break program design down to a science, rather than typing characters and hoping.

Much of what I learned from this course stems from the fact that the Racket programming language is purely functional. Due to the absence of state, you are required to use helper functions and recursion to implement programs. After taking this course, I understand and feel more comfortable using induction to design recursive functions. I also learned about and have a better understanding of:
* Data structures like binary search trees, arbitrary arity trees, and graphs.
* Searching, sorting, and other algorithms.
* The difference between structural and generative recursion, and how to implement them.
* Lambda expressions.
### 👎 Dislikes
The DrRacket IDE is slow and clunky, and many keywords in the Racket language are oddly cryptic. Writing a "big-bang" function for my "world program" was just one of many times when I wondered if the creators of Racket thought it more important to be unique than practical. In addition to this, every expression in Racket is enclosed in parentheses. _This came to its natural conclusion when I found myself nesting up to eight sets of parentheses for a program_. While this issue can be partially remedied by careful and consistent indentation, it makes the program design process a nightmare. I believe that the onus for designing readable code should fall on the designer(s) of a language's syntax first and foremost. Programmers should not be limited by a programming language when trying to write readable code.

A major gripe with the course specificlly is that the final project is off-limits to students that do not pay for the certificate of completion. I would have liked the opportunity to use the skills I developed through the second half of the course in a cumulative exercise. The practice problems and midterm project are available for free, so I in reality I don't feel like I missed out on much.
### 🤔 Suggestions for Students
Get comfortable using recursion. A purely functional programming language means no iteration, which means that you need to gain a deep understanding of recursive programs in order to succeed.

Like Kiczales suggests, program ahead of him at times (when you are feeling confident) to prove to yourself that you aren't blindly programming along with him.
## 🔑 *Key Takeaways*
* Systematic design uses higher-level design concepts to break down complicated problems to a point where one can solve them simply.
* Identifying the structure of information is a key step in program design.
* Unit tests should be made before writing a function, as this allows you to figure out what you really want the output of the function to be.
* Given a base case, trust that the natural recursion in a program will work as expected.
  
---

### README Changelog
Date | Changes
--- | ---
November 25, 2023 | <ul><li>**ADDED**<ul><li>Preface</li><li>Harvard - CS50 - Introduction to Programming with Python.</li></ul></li></ul>
December 25, 2023 |  <ul><li>**ADDED**<ul><li>Table of Contents</li><li>MIT - 6.0001 - Introduction to Computer Science and Programming using Python.</li></ul></li><li>**REVISED**<ul><li>Preface</li><li>Harvard - CS50 - Introduction to Programming with Python.</li></ul></li></ul>
January 03, 2024 | <ul><li>**ADDED**<ul><li>UBC - CPSC110 - Systematic Program Design.</li></ul></li></ul>
